# üöÄ RFC-002: Reactless State, Effects, and Dynamic Features Integration

> **Advanced React Feature Compatibility in a Static-First World**

| Metadata | Details |
| :--- | :--- |
| **Status** | Draft |
| **Authors** | Mohammed Aman Khan |
| **Created** | 2024-11-23 |
| **Last Updated** | 2025-11-23 |
| **Scope** | State Management, Effects, Refs, Dynamic Patterns |
| **Components** | `StateBridge`, `EffectManager`, `DynamicSlot`, `RefProxy` |

## üìã Table of Contents

- [1. Executive Summary](#1-executive-summary)
- [2. Problem Statement](#2-problem-statement)
- [3. Core Challenges](#3-core-challenges)
- [4. Proposed Architecture](#4-proposed-architecture)
- [5. State Management Integration](#5-state-management-integration)
- [6. Effects & Lifecycle Handling](#6-effects--lifecycle-handling)
- [7. Dynamic Content & Slots](#7-dynamic-content--slots)
- [8. Refs & Imperative Handles](#8-refs--imperative-handles)
- [9. Context & Dependency Injection](#9-context--dependency-injection)
- [10. Performance Considerations](#10-performance-considerations)
- [11. Implementation Strategy](#11-implementation-strategy)
- [12. Appendix](#12-appendix)

## 1. Executive Summary

While RFC-001 solved the event system and hydration challenges, **RFC-002 addresses the complex interplay between React's dynamic features and Reactless's static optimization**. This proposal enables seamless integration of:

- **State updates** that only affect dynamic portions
- **Effects** that work alongside static DOM
- **Dynamic children and slots** within static structures
- **Ref forwarding** to both static and dynamic elements
- **Context updates** that efficiently propagate through optimized trees

The solution maintains React's declarative programming model while achieving near-native DOM performance.

## 2. Problem Statement

React's power comes from its reactive state system and component lifecycle. When we optimize static content, we must preserve these capabilities without compromising performance.

### 2.1 The State Update Dilemma

```javascript
function InteractiveCard({ user }) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [likes, setLikes] = useState(0);

  return (
    <div className="card">
      {/* Static structure */}
      <header className="card-header">
        <h2>{user.name}</h2>
        <span className="badge">Pro</span> {/* Static */}
      </header>
      
      {/* Dynamic content based on state */}
      <div className="card-body">
        {isExpanded ? (
          <p>{user.bio}</p>  {/* Dynamic */}
        ) : (
          <p>{user.bio.slice(0, 100)}...</p>  {/* Dynamic */}
        )}
        
        {/* Interactive elements with state */}
        <div className="actions">
          <button onClick={() => setLikes(l => l + 1)}>
            üëç {likes}  {/* Dynamic */}
          </button>
          <button onClick={() => setIsExpanded(e => !e)}>
            {isExpanded ? 'Show Less' : 'Show More'}  {/* Dynamic */}
          </button>
        </div>
      </div>
      
      {/* Static footer */}
      <footer className="card-footer">
        <span>Joined {user.joinDate}</span>  {/* Static */}
      </footer>
    </div>
  );
}
```

**Challenge:** How do we optimize the static portions (header, footer) while maintaining reactive updates for dynamic portions (body, actions)?

### 2.2 Effect Coordination Problems

```javascript
function DataDrivenComponent({ id }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchData(id).then(result => {
      setData(result);
      setLoading(false);
    });
  }, [id]);

  return (
    <div className="container">
      {/* Static navigation */}
      <nav className="sidebar">...</nav>
      
      {/* Dynamic content based on effects */}
      <main className="content">
        {loading ? (
          <div className="skeleton-loader">...</div>  {/* Dynamic */}
        ) : (
          <article>
            <h1>{data.title}</h1>  {/* Dynamic */}
            <p>{data.content}</p>  {/* Dynamic */}
          </article>
        )}
      </main>
      
      {/* Static footer */}
      <footer>...</footer>
    </div>
  );
}
```

**Challenge:** Effects trigger re-renders that should only update specific dynamic regions, not the entire static structure.

## 3. Core Challenges

### 3.1 Granular State Updates
- State changes should only recompute and update affected dynamic regions
- Static portions should never re-render, even when parent state changes
- Multiple state variables should update independently

### 3.2 Effect Isolation
- Effects should run in proper lifecycle order
- Cleanup functions should work correctly
- Effect dependencies should trigger minimal updates

### 3.3 Dynamic Content Integration
- Children props and render props need dynamic slots
- Conditional rendering and list rendering require flexible boundaries
- Portal content must be handled correctly

### 3.4 Ref Management
- Refs to static DOM elements must be forwarded
- useImperativeHandle should work with optimized components
- Callback refs need special handling

### 3.5 Context Propagation
- Context consumers in static regions need updates
- Nested context providers must work correctly
- Context changes should only update subscribers

## 4. Proposed Architecture

### 4.1 The "Dynamic Island" Pattern

Reactless reintroduces the concept of **Dynamic Islands** (similar to **Dynamic Islands** in Deno Fresh) - isolated regions within static templates that can react to state and props changes.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Static Template Root               ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ   Static    ‚îÇ  ‚îÇ  Dynamic    ‚îÇ  ‚îÇ Static  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   Header    ‚îÇ  ‚îÇ   Island    ‚îÇ  ‚îÇ Footer  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ ‚îÇ State A ‚îÇ ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ ‚îÇ Updates ‚îÇ ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ ‚îÇ  Here   ‚îÇ ‚îÇ  ‚îÇ         ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 4.2 Compiler-Driven Dynamic Slot Detection

The compiler analyzes component state usage and effect dependencies to automatically identify dynamic boundaries.

```javascript
// Source Component
function UserProfile({ user }) {
  const [isEditing, setIsEditing] = useState(false);
  const [draftBio, setDraftBio] = useState(user.bio);

  useEffect(() => {
    document.title = `${user.name}'s Profile`;
  }, [user.name]);

  return (
    <div className="profile">
      {/* Static: No state/props dependencies */}
      <header className="profile-header">
        <h1>User Profile</h1>
        <div className="decoration"></div>
      </header>
      
      {/* Dynamic Island: State-dependent */}
      <div className="profile-content">
        {isEditing ? (
          <textarea 
            value={draftBio}
            onChange={(e) => setDraftBio(e.target.value)}
          />
        ) : (
          <p className="bio">{user.bio}</p>
        )}
      </div>
      
      {/* Dynamic Island: Multiple state variables */}
      <div className="profile-actions">
        <button onClick={() => setIsEditing(!isEditing)}>
          {isEditing ? 'Save' : 'Edit'}
        </button>
        <span className="status">
          {isEditing ? 'Editing...' : 'Ready'}
        </span>
      </div>
    </div>
  );
}

// Compiled Output
const _template = {
  static: `
    <div class="profile">
      <header class="profile-header">
        <h1>User Profile</h1>
        <div class="decoration"></div>
      </header>
      <div class="profile-content" data-slot="content"></div>
      <div class="profile-actions" data-slot="actions"></div>
    </div>
  `,
  dynamic: {
    slots: {
      content: {
        type: 'conditional',
        dependencies: ['isEditing', 'draftBio', 'user.bio']
      },
      actions: {
        type: 'multiple',
        dependencies: ['isEditing']
      }
    }
  }
};
```

## 5. State Management Integration

### 5.1 Fine-Grained State Reactivity

Reactless creates optimized update paths for each state variable, bypassing React's normal render cycle for static content.

```typescript
interface StateBridge {
  // Tracks which state variables affect which dynamic slots
  dependencies: Map<string, Set<string>>;
  
  // Direct update methods for each slot type
  updateText: (selector: string, value: string) => void;
  updateAttribute: (selector: string, attr: string, value: any) => void;
  updateConditional: (slotId: string, condition: boolean, branches: TemplateBranch[]) => void;
  updateList: (slotId: string, items: any[], itemTemplate: TemplateFunction) => void;
}

class ReactiveStateManager {
  private stateProxies = new Map<string, StateProxy>();
  private updateScheduler = new UpdateScheduler();
  
  createStateProxy<T>(initialValue: T, dependencies: string[]): [T, (value: T) => void] {
    const stateId = generateId();
    const [value, setValue] = useState(initialValue);
    
    const proxy = new StateProxy(value, setValue, dependencies);
    this.stateProxies.set(stateId, proxy);
    
    return [value, (newValue: T) => {
      setValue(newValue);
      this.scheduleSlotUpdates(dependencies, newValue);
    }];
  }
  
  private scheduleSlotUpdates(dependencies: string[], newValue: any) {
    // Find all slots that depend on this state
    const affectedSlots = this.findAffectedSlots(dependencies);
    
    // Schedule granular updates
    affectedSlots.forEach(slot => {
      this.updateScheduler.schedule(slot.id, () => {
        slot.update(newValue);
      });
    });
  }
}
```

### 5.2 State Update Examples

```javascript
// Complex state scenario
function AdvancedComponent() {
  const [filters, setFilters] = useState({ category: 'all', sort: 'newest' });
  const [items, setItems] = useState([]);
  const [selectedItem, setSelectedItem] = useState(null);
  const [viewMode, setViewMode] = useState('grid');

  // Each state update only affects specific slots
  return (
    <div className="advanced-component">
      {/* Static header */}
      <header>Product Browser</header>
      
      {/* Filters slot - depends on filters state */}
      <div className="filters">
        <select 
          value={filters.category} 
          onChange={e => setFilters(f => ({ ...f, category: e.target.value }))}
        >
          <option value="all">All</option>
          <option value="electronics">Electronics</option>
        </select>
      </div>
      
      {/* Items slot - depends on items, filters, viewMode */}
      <div className="items-container">
        {viewMode === 'grid' ? (
          <div className="grid">
            {filteredItems.map(item => (
              <ProductCard 
                key={item.id} 
                item={item}
                onSelect={setSelectedItem}
              />
            ))}
          </div>
        ) : (
          <div className="list">
            {filteredItems.map(item => (
              <ProductRow 
                key={item.id} 
                item={item}
                onSelect={setSelectedItem}
              />
            ))}
          </div>
        )}
      </div>
      
      {/* Detail slot - depends on selectedItem */}
      <div className="detail-panel">
        {selectedItem && <ProductDetail item={selectedItem} />}
      </div>
    </div>
  );
}
```

## 6. Effects & Lifecycle Handling

### 6.1 Effect Coordination System

Effects are coordinated to ensure proper execution order and cleanup, even when components are partially static.

```typescript
class EffectManager {
  private effectQueue = new PriorityQueue<Effect>();
  private cleanupRegistry = new Map<string, CleanupFunction>();
  
  registerEffect(
    effectId: string,
    effect: EffectFunction,
    dependencies: any[],
    priority: EffectPriority = 'normal'
  ) {
    // Compare dependencies to determine if effect should run
    const shouldRun = this.hasDependenciesChanged(effectId, dependencies);
    
    if (shouldRun) {
      // Schedule effect execution
      this.effectQueue.enqueue({
        id: effectId,
        execute: () => {
          // Run cleanup if exists
          this.runCleanup(effectId);
          
          // Execute effect and store cleanup
          const cleanup = effect();
          if (cleanup) {
            this.cleanupRegistry.set(effectId, cleanup);
          }
        },
        priority
      });
    }
  }
  
  private hasDependenciesChanged(effectId: string, newDeps: any[]): boolean {
    const oldDeps = this.dependencyCache.get(effectId);
    this.dependencyCache.set(effectId, newDeps);
    
    if (!oldDeps) return true;
    return !shallowEqual(oldDeps, newDeps);
  }
}
```

### 6.2 Effect Integration Examples

```javascript
function ComponentWithEffects() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  // Effect 1: Data fetching
  useEffect(() => {
    let cancelled = false;
    
    const fetchData = async () => {
      setLoading(true);
      try {
        const result = await api.fetchData();
        if (!cancelled) {
          setData(result);
          setError(null);
        }
      } catch (err) {
        if (!cancelled) {
          setError(err.message);
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };
    
    fetchData();
    
    return () => {
      cancelled = true;
    };
  }, []);

  // Effect 2: Analytics
  useEffect(() => {
    if (data) {
      analytics.track('data_loaded', { count: data.length });
    }
  }, [data]);

  // Effect 3: DOM manipulation (escape hatch)
  useEffect(() => {
    const element = document.querySelector('.special-element');
    if (element) {
      element.classList.add('animated');
      return () => element.classList.remove('animated');
    }
  }, []);

  return (
    <div className="component">
      <header>Data Dashboard</header>
      
      {/* Loading state */}
      {loading && <div className="loader">Loading...</div>}
      
      {/* Error state */}
      {error && <div className="error">{error}</div>}
      
      {/* Data display */}
      {data && (
        <div className="data-grid">
          {data.map(item => (
            <DataCard key={item.id} data={item} />
          ))}
        </div>
      )}
      
      <footer>Static Footer</footer>
    </div>
  );
}
```

## 7. Dynamic Content & Slots

### 7.1 Slot-Based Dynamic Content

Reactless introduces a slot system for dynamic content within static templates.

```typescript
interface DynamicSlot {
  id: string;
  type: 'text' | 'attribute' | 'conditional' | 'list' | 'children';
  selector: string;
  updateStrategy: 'immediate' | 'batched' | 'deferred';
  dependencies: string[];
}

class SlotManager {
  private slots = new Map<string, DynamicSlot>();
  private updateQueue = new UpdateQueue();
  
  registerSlot(slot: DynamicSlot) {
    this.slots.set(slot.id, slot);
  }
  
  updateSlot(slotId: string, data: any) {
    const slot = this.slots.get(slotId);
    if (!slot) return;
    
    this.updateQueue.enqueue({
      slotId,
      execute: () => this.executeSlotUpdate(slot, data),
      priority: slot.updateStrategy === 'immediate' ? 'high' : 'normal'
    });
  }
  
  private executeSlotUpdate(slot: DynamicSlot, data: any) {
    switch (slot.type) {
      case 'text':
        this.updateTextContent(slot.selector, data);
        break;
      case 'conditional':
        this.updateConditional(slot.selector, data);
        break;
      case 'list':
        this.updateList(slot.selector, data);
        break;
      case 'children':
        this.updateChildren(slot.selector, data);
        break;
    }
  }
}
```

### 7.2 Advanced Slot Patterns

```javascript
// Children slots with dynamic content
function LayoutComponent({ sidebar, mainContent, footer }) {
  return (
    <div className="layout">
      {/* Static layout structure */}
      <aside className="sidebar" data-slot="sidebar">
        {/* Dynamic sidebar content injected here */}
      </aside>
      
      <main className="content" data-slot="main">
        {/* Dynamic main content */}
      </main>
      
      <footer className="app-footer" data-slot="footer">
        {/* Dynamic footer content */}
      </footer>
    </div>
  );
}

// Conditional rendering with multiple branches
function ToggleComponent({ defaultTab }) {
  const [activeTab, setActiveTab] = useState(defaultTab);
  
  return (
    <div className="tabs">
      {/* Static tab headers */}
      <div className="tab-headers">
        <button 
          className={activeTab === 'info' ? 'active' : ''}
          onClick={() => setActiveTab('info')}
        >
          Information
        </button>
        <button 
          className={activeTab === 'settings' ? 'active' : ''}
          onClick={() => setActiveTab('settings')}
        >
          Settings
        </button>
      </div>
      
      {/* Dynamic tab content */}
      <div className="tab-content" data-slot="tabContent">
        {activeTab === 'info' && <InfoTab />}
        {activeTab === 'settings' && <SettingsTab />}
      </div>
    </div>
  );
}

// List rendering with optimized updates
function ProductList({ products, onProductUpdate }) {
  const [sortBy, setSortBy] = useState('name');
  
  const sortedProducts = useMemo(() => {
    return [...products].sort((a, b) => a[sortBy].localeCompare(b[sortBy]));
  }, [products, sortBy]);

  return (
    <div className="product-list">
      {/* Static controls */}
      <div className="controls">
        <select value={sortBy} onChange={e => setSortBy(e.target.value)}>
          <option value="name">Name</option>
          <option value="price">Price</option>
        </select>
      </div>
      
      {/* Dynamic list with optimized updates */}
      <ul className="products" data-slot="productList">
        {sortedProducts.map(product => (
          <ProductItem 
            key={product.id}
            product={product}
            onUpdate={onProductUpdate}
          />
        ))}
      </ul>
    </div>
  );
}
```

## 8. Refs & Imperative Handles

### 8.1 Ref Forwarding System

Reactless provides comprehensive ref support for both static and dynamic elements.

```typescript
interface RefHandler {
  // For DOM element refs
  handleElementRef: (element: HTMLElement | null) => void;
  
  // For component refs with imperative handles
  handleComponentRef: (instance: ComponentInstance | null) => void;
  
  // For callback refs
  handleCallbackRef: (element: HTMLElement | null) => void;
}

class RefManager {
  private elementRefs = new Map<string, RefObject>();
  private componentRefs = new Map<string, ComponentRef>();
  
  registerElementRef(refId: string, element: HTMLElement) {
    this.elementRefs.set(refId, { current: element });
    
    // Notify all registered ref callbacks
    this.notifyRefCallbacks(refId, element);
  }
  
  createProxyRef(originalRef: RefObject): ProxyRef {
    return {
      current: null,
      // Proxy all property accesses to the actual DOM element
      get: (target, prop) => {
        const element = this.findElementForRef(originalRef);
        return element ? element[prop] : undefined;
      },
      // Forward method calls to the actual element
      apply: (target, thisArg, argumentsList) => {
        const element = this.findElementForRef(originalRef);
        return element?.[target].apply(element, argumentsList);
      }
    };
  }
}
```

### 8.2 Advanced Ref Patterns

```javascript
// Forwarding refs to static elements
const StaticButton = React.forwardRef((props, ref) => {
  return (
    <button 
      {...props}
      ref={ref}  // This ref points to the actual DOM button
      className={`static-button ${props.className || ''}`}
    >
      {props.children}
    </button>
  );
});

// Imperative handle with static components
const Modal = React.forwardRef((props, ref) => {
  const [isOpen, setIsOpen] = useState(false);
  const modalRef = useRef(null);

  useImperativeHandle(ref, () => ({
    open: () => setIsOpen(true),
    close: () => setIsOpen(false),
    // Expose the underlying DOM element
    getElement: () => modalRef.current,
    // Custom methods
    shake: () => {
      if (modalRef.current) {
        modalRef.current.classList.add('shake');
        setTimeout(() => modalRef.current.classList.remove('shake'), 500);
      }
    }
  }));

  return (
    <div 
      ref={modalRef}
      className={`modal ${isOpen ? 'open' : 'closed'}`}
      data-slot="modalContent"
    >
      {/* Static modal structure */}
      <div className="modal-header">
        <h2>{props.title}</h2>
        <button onClick={() => setIsOpen(false)}>√ó</button>
      </div>
      <div className="modal-body">
        {props.children}
      </div>
    </div>
  );
});

// Using refs with optimized components
function ParentComponent() {
  const modalRef = useRef(null);
  const buttonRef = useRef(null);

  const handleOpenModal = () => {
    modalRef.current?.open();
    
    // The button ref still works even though it's in a static region
    buttonRef.current?.classList.add('clicked');
  };

  return (
    <div>
      {/* Static button with ref */}
      <button 
        ref={buttonRef}
        onClick={handleOpenModal}
        className="open-modal-btn"
      >
        Open Modal
      </button>
      
      {/* Optimized modal with imperative handle */}
      <Modal ref={modalRef} title="Example Modal">
        <p>Modal content here</p>
      </Modal>
    </div>
  );
}
```

## 9. Context & Dependency Injection

### 9.1 Context-Aware Optimization

Reactless intelligently handles context consumption in optimized components.

```typescript
class ContextIntegration {
  private contextConsumers = new Map<string, ContextConsumer>();
  private contextSubscriptions = new Map<string, Set<string>>();
  
  registerContextConsumer(
    componentId: string, 
    context: React.Context<any>,
    selector?: (value: any) => any
  ) {
    const consumer = new ContextConsumer(context, selector);
    this.contextConsumers.set(componentId, consumer);
    
    // Subscribe to context changes
    this.subscribeToContext(context, componentId);
  }
  
  private subscribeToContext(context: React.Context<any>, consumerId: string) {
    const contextId = getContextId(context);
    
    if (!this.contextSubscriptions.has(contextId)) {
      this.contextSubscriptions.set(contextId, new Set());
    }
    
    this.contextSubscriptions.get(contextId)!.add(consumerId);
  }
  
  handleContextUpdate(context: React.Context<any>, newValue: any) {
    const contextId = getContextId(context);
    const subscribers = this.contextSubscriptions.get(contextId);
    
    subscribers?.forEach(consumerId => {
      const consumer = this.contextConsumers.get(consumerId);
      if (consumer) {
        consumer.update(newValue);
      }
    });
  }
}
```

### 9.2 Context Integration Examples

```javascript
// Complex context consumption
const ThemeContext = React.createContext('light');
const UserContext = React.createContext(null);
const FeaturesContext = React.createContext([]);

function ContextHeavyComponent() {
  const theme = useContext(ThemeContext);
  const user = useContext(UserContext);
  const features = useContext(FeaturesContext);
  
  const canEdit = features.includes('edit');
  const isPremium = user?.tier === 'premium';

  return (
    <div className={`app ${theme}`}>
      {/* Static structure with context-dependent classes */}
      <header className="app-header">
        <h1>Welcome{user ? `, ${user.name}` : ''}</h1>
        
        {/* Dynamic based on context */}
        {isPremium && <span className="premium-badge">Premium</span>}
      </header>
      
      <main className="app-main">
        {/* Context-dependent rendering */}
        {user ? (
          <Dashboard user={user} canEdit={canEdit} />
        ) : (
          <LoginForm />
        )}
      </main>
      
      {/* Static footer with theme */}
      <footer className="app-footer">
        <p>¬© 2024 My App</p>
        {isPremium && <p>Thank you for being a premium member!</p>}
      </footer>
    </div>
  );
}

// Nested context providers with optimization
function AppWithProviders() {
  const [theme, setTheme] = useState('light');
  const [user, setUser] = useState(null);
  const [features, setFeatures] = useState(['read']);

  return (
    <ThemeContext.Provider value={theme}>
      <UserContext.Provider value={user}>
        <FeaturesContext.Provider value={features}>
          {/* This component can still be partially optimized */}
          <ContextHeavyComponent />
          
          {/* Control panel - separate optimization boundary */}
          <div className="control-panel">
            <button onClick={() => setTheme(t => t === 'light' ? 'dark' : 'light')}>
              Toggle Theme
            </button>
            <button onClick={() => setUser({ name: 'John', tier: 'premium' })}>
              Login
            </button>
          </div>
        </FeaturesContext.Provider>
      </UserContext.Provider>
    </ThemeContext.Provider>
  );
}
```

## 10. Performance Considerations

### 10.1 Update Cost Analysis

| Update Type | Standard React | Reactless | Improvement |
|-------------|----------------|-----------|-------------|
| **Text Content** | Full re-render | Direct text update | 50-100x |
| **Attribute Change** | Full re-render | Direct attribute set | 20-50x |
| **List Item Update** | Re-render all | Update single item | 10-100x |
| **Conditional Branch** | Full re-render | Template swap | 5-20x |

### 10.2 Memory Optimization

```typescript
class MemoryManager {
  private templateCache = new LRUCache<string, TemplateInstance>(100);
  private slotCache = new WeakMap<Element, SlotInstance>();
  private stateSnapshotCache = new Map<string, StateSnapshot>();
  
  optimizeMemoryUsage() {
    // Clear unused templates
    this.templateCache.prune();
    
    // Compact state snapshots
    this.compactStateSnapshots();
    
    // Release detached DOM references
    this.cleanupDetachedElements();
  }
  
  private compactStateSnapshots() {
    for (const [key, snapshot] of this.stateSnapshotCache) {
      if (!snapshot.isActive) {
        this.stateSnapshotCache.delete(key);
      }
    }
  }
}
```

## 11. Implementation Strategy

### Phase 1: Core State Integration (6 weeks)
- [ ] State dependency analysis in compiler
- [ ] Basic slot system for dynamic content
- [ ] Text and attribute updates
- [ ] Simple conditional rendering

### Phase 2: Advanced Features (5 weeks)
- [ ] Effect coordination system
- [ ] List rendering optimization
- [ ] Ref forwarding implementation
- [ ] Context integration

### Phase 3: Performance Optimization (4 weeks)
- [ ] Update batching and scheduling
- [ ] Memory management
- [ ] Bundle size optimization
- [ ] Performance benchmarking

### Phase 4: Production Refinement (3 weeks)
- [ ] Edge case handling
- [ ] Comprehensive testing
- [ ] DevTools integration
- [ ] Documentation

## 12. Appendix

### 12.1 Bailout Conditions

The compiler will bail out of optimization for:

```typescript
const BAILOUT_CONDITIONS = {
  // Complex state patterns
  USE_REDUCER: 'useReducer hooks with complex reducers',
  USE_IMPERATIVE_HANDLE: 'useImperativeHandle with dynamic methods',
  CUSTOM_HOOKS: 'Custom hooks with unknown side effects',
  
  // Complex context patterns
  CONTEXT_SELECTOR: 'Context selectors with complex logic',
  DYNAMIC_CONTEXT: 'Dynamically created context providers',
  
  // Advanced React patterns
  ERROR_BOUNDARIES: 'Components that implement componentDidCatch',
  SUSPENSE: 'Components that use React Suspense directly',
  FORWARD_REF_COMPLEX: 'forwardRef components with complex logic'
};
```

### 12.2 Migration Strategy

```javascript
// Before: Fully dynamic React component
function OriginalComponent({ data, onUpdate }) {
  const [localState, setLocalState] = useState('');
  const inputRef = useRef(null);
  
  useEffect(() => {
    // Complex effect logic
  }, [data]);
  
  return (
    <div className="complex-component">
      <header>
        <h1>{data.title}</h1>
        <button onClick={() => onUpdate(data)}>Update</button>
      </header>
      <main>
        <input 
          ref={inputRef}
          value={localState}
          onChange={e => setLocalState(e.target.value)}
        />
        <div className="content">
          {data.items.map(item => (
            <Item key={item.id} item={item} />
          ))}
        </div>
      </main>
    </div>
  );
}

// After: Gradual optimization with Reactless
function OptimizedComponent({ data, onUpdate }) {
  const [localState, setLocalState] = useState('');
  const inputRef = useRef(null);
  
  useEffect(() => {
    // Complex effect logic - remains dynamic
  }, [data]);
  
  return (
    <ReactlessNode 
      template={complexTemplate}
      data={{
        title: data.title,
        items: data.items,
        localState
      }}
      events={{
        updateButton: onUpdate.bind(null, data),
        inputChange: setLocalState
      }}
      refs={{
        input: inputRef
      }}
    >
      {/* Dynamic children that can't be optimized */}
      {data.items.map(item => (
        <ComplexItem key={item.id} item={item} />
      ))}
    </ReactlessNode>
  );
}
```

This RFC establishes a comprehensive framework for integrating React's dynamic features with Reactless's static optimization, enabling significant performance improvements while maintaining full React compatibility.
